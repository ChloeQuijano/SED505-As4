# Questions
1. Why should this code be written in C/C++ only? Why not Java, C# or Python?

C/C++ is the most appropriate language due to its superior performance, runtime capabilities, and control over system resources compared to other languages. In terms of performance, C/C++ offers fine-grained control over memory and system resources, making it ideal for the development of highly efficient code, especially in smaller environments with limited memory and processing power. Additionally, C/C++ code compiles directly into machine code, making it the fastest choice for real-time calculations, such as the Taylor Series, in contrast to other languages that rely on virtual machines (Java and C#) or interpreters (Python). This lack of runtime overhead in C/C++ applications supports efficient memory management, reducing runtime resource consumption. This makes C/C++ more suitable than Java, C#, or Python for devices with stricter memory constraints. Furthermore, the mathematical computations required for this code benefit from C/C++'s ability to implement custom calculations without relying on external math libraries. This direct implementation of the sine wave function at a low level reduces code size, unlike Java, C#, and Python, which depend on math libraries, introducing additional overhead and making them impractical for constrained environments.

2. Name two other possible common usages for this design pattern.

- Web Application: The MVC pattern is widely used in web development frameworks. This is where the Model handles any interactions with a database, the View would be the front end displaying HTML and user interfaces and the Controller manages the user inputs and orchestrates communication between the Model and View.
- GUI Applications on the Desktop: For example, applications like a text editor or drawing tool would have a Model that manages data within (example: document content or the shapes being drawn), the View will render the user interface and the Controller processes the user interactions (example: mouse clicks, keystrokes).

3. What might cause a test build to behave differently from a release build?

Test builds in this project contains additional debuggimng informtaion, directives like #ifndef TEST_BUILD, leading to behavioral differecnes. Release builds are optimized for performance, excluding debuf information, which might result in variation in timing.

4. Did you use interface classes for all components in this assignment? If not, why?

No, we did not use interface classes for all the components. We mainly used it in `View` through implementing `ConsoleView` and `Graphical View`. This ensured that the views we created comform to a common interface allowing our controller to interact with any view in a consistent way. Where we didnt use it was our Model `TaylorSeries` and `Controller`. We implemented them as concrete classes rather than an interface because for our model `TaylorSeries`, there was only one implementation (Taylor Series computation). Adding an interface would add unnecessary complexity with no benefit. Since the primary focus of our model is to encapsulate the logic for training and predicting, there is no indication that we want to add additional implementations like mathematical models required to justify adding an interface. Alongside, the `Controller`was implemented as a concrete class because its responsibility in managing interactions between the model and views are well defined. We recognized no requirement for multiple types of controllers so using an interface would add unnecessary complexity. Due to these decisions, we selectively used interfaces where they added for multiple types like in `View` but found that if it wasn't needed then a concrete implementation was sufficient adhering to a principle of keeping design as simple as possible.
   
